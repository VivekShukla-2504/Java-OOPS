OOPS = A PROGRAMMING PARADOGM THAT USES OBJECT AND CLASSES 
TO DESIGN AND IMPLEMENT SOFTWARE SOLUTIONS.
1) CLASS=> IT IS  A BLUEPRINT FOR CREATING OBJECTS. 
IT DEFINES THE STRUCTURE(FEILDS) AND BEHAVIOUR (METHODS) OF OBJECTS.
EX = FEILDS means variable
let see a example of car= it has a color,speed and car is driving is a BEHAVIOUR
class  car{
    String color;
    int speed;

void drive()
{
    System.out.println("car is driving");
}
}

2) OBJECT=> AN OBJECT IS AN INSTANCE OF A CLASS.
IT REPERESENTS A REAL-WORLD ENTITY AND HAS ATTRIBUTES AND BEHAVIORS.
EX => car myCar = new Car();
myCar.color = "Red";
myCar.drive();


3) ENCAPSULATION IS THE PRACTICE OF BUNDLING DATA AND METHODS(FUNCTIONS) 
THAT OPERATE ON THE DATA INTO A SINGLE UNIT(CLASS).
IT ALSO INVOLVES RESTRICTING DIRECT ACCESS TO SOME 
COMPONENTS USING ACCESS MODIFIERS(E.G., PRIVATE,PROTECTED).

// CONSTRUCTOR IS A METHODS TO INITIALIZE NEW OBJECTS
Car()

4)INHERITANCE IT ALLOWS A CLASS TP ACQUIRE PROPERTIES AND METHODS OF ANOTHER CLASS.
 IT SUPPORTS CODE REUSABILITY
  EX => CLASS ANIMAL 
  {
    VOID EAT()
    {
        SYSTEM.OUT.PRINTLN("THIS ANIMAL EATS FOOD.");
    }
  }
  CLASS DOG EXTENDS ANIMAL // HERE CLASS DOG EXTEND THE PROPERTY OF ANIMAL CLASS
  { VOID BARK()
  {
    SYSTEM.OUT.PRINTLN("DOG BARKS");
  }

  }
  //NOTE JAVA DOES NOT SUPPORT MULTIPLE INHERITANCE=>SOLUTION INTERFACES
  I) SINGLE  II)MULTILEVEL  III)HIERARCHICAL

  5)POLYMORPHISM : (MANY FORMS)  IT ALLOWS METHODS TO PERFORM 
  DIFFERENT TASKS BASED ON THE OBJECT THAT CALLS THEM.
  IT CAN BE ACHEIVED VIA:
  I)COMPILE TIME ( METHOD OVERLOADING):METHOD OVERLOADING IN JAVA IS A FEATURE THAT ALLOWS TO HAVE MULTIPLE METHODS WITH THE SAME NAME BUT DIFFERENT PARAMETER LISTS. 
  IT ENABLES A METHOD TO PERFORM DIFFERENT TASKS.
  DEPENDING ON THE ARGUMENTS PASSED TO IT.
   EX=> CLASS CALCULTOR
   { int add(int a,int b)
   {
    return a+b;
   }
   int add(int a,int b,int c)
   {
    return a+b+c;
   }
   }
   public class Main
   {
    public static void main(String[] args) {
            CALCULTOR calc = new CALCULTOR();
            System.out.println(calc.add(2,3));
            System.out.println(calc.add(1,2,3));// same name but complier determine based on PARAMETER this is called compile time polymorphism
            
    }
   }
  II) RUNTIME POLYMORMISM(METHOD OVERRIDING):its acheived through method overriding, 
  where a subclass provide a specific  implementation of
a method already defined in its parent class. the method
 to be called is determined at runtime based on  the object.
example=> enigneering digest vedios of java 1:26:00


6)ABSTRACTION : IT FOCUSES ON SHOWING ONLY ESSENTIALS DETAILS WHILE HIDING THE IMPLEMENTATION. 
IT IS ACHIEVED THROUGH ABSTRACT CLASSES AND INTERFACES.
I) ABSTRACT CLASSES: USING ABSTRACT KEYWORD, CANNOT BE INSTANTIATED DIRECTLY.
II) INTERFACE --> BLUEPRINT FOR CLASS USE IMPLEMENTS
BY INTERFACES,WE ACHEIVE ABSTRACTION AND MULTIPLE INHERITANCE,
IT CAN HAVE  ABSTRACT METHODS, STATIC METHODS AND DEFAULT METHODS.
//JAVA ME FINAL KEYWORD HOTA HAI CONSTANT KO DEFINE KARNE KE LIYE
**STATIC METHOD IN INTERFACES:
;; USED FOR UTILITY OPERATIONS 
THAT ARE RELATED  TO THE INTERFACE BUT DONT NEED INSTANCE STATE
;;Cannot be overridden  by implementing classes 
;;called DIRECTLY on the interface(not through instance)
**DEFAULT METHODS:
;;IT PROVIDES OPTIONAL FUNCTINALITY TO IMPLEMNENTING CLASSES
;; CAN BE OVERRIDEN IF NEEDED
;;CAN USE OTHER INTERFACE METHODS(ABSTRACT OR DEFAULT)
;;CALLED THROUGH INSTANCE

INTERFACE VS ABSTRACT CLASS
IN INTERFACE WE CANNNOT USE FEILDS AND INSTANCE VARIABLES WE USE ONLLY STATIC FEILD, IN INTERFACE WE ACHEIVE MULTIPLE INHERITANCE
WHILE IN  ABSTRACT CLASS WE USE FEILDS, INSTANCE VARIABLES BUT CANNOT BE ACHEIVE MULTIPLE INHERITANCE
